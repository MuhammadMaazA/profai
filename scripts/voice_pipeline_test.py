#!/usr/bin/env python3
"""
Complete Voice-to-Voice Test - Full pipeline test
"""
import os
import sys
from pathlib import Path

# Ensure src is on path
ROOT = Path(__file__).resolve().parents[1]
SRC = ROOT / "src"
if str(SRC) not in sys.path:
    sys.path.insert(0, str(SRC))

def test_voice_to_voice_pipeline():
    """Test the complete voice-to-voice pipeline"""
    print("ğŸ¤â¡ï¸ğŸ¤–â¡ï¸ğŸ”Š Testing Complete Voice-to-Voice Pipeline")
    print("=" * 60)
    
    try:
        from profai.config import settings
        from profai.stt import STTClient
        from profai.llm import LLMClient  
        from profai.tts import TTSClient
        
        # Check all API keys
        print("ğŸ” Checking API configuration...")
        
        issues = []
        if not settings.elevenlabs_api_key or not settings.elevenlabs_api_key.startswith("sk_"):
            issues.append("ElevenLabs API key for TTS")
            
        if settings.use_gemini:
            if not settings.gemini_api_key:
                issues.append("Gemini API key for LLM")
        else:
            if not settings.openai_api_key:
                issues.append("OpenAI API key for LLM")
        
        # For STT we need OpenAI (separate from LLM)
        if not settings.openai_api_key:
            issues.append("OpenAI API key for STT")
        
        if issues:
            print(f"âŒ Missing: {', '.join(issues)}")
            return False
        
        print("âœ… All API keys configured")
        print(f"   - Using {'Gemini' if settings.use_gemini else 'OpenAI'} for LLM")
        print(f"   - Using OpenAI Whisper for STT")
        print(f"   - Using ElevenLabs for TTS")
        
        # Initialize all clients
        print("\nğŸ”§ Initializing clients...")
        stt = STTClient()
        llm = LLMClient()
        tts = TTSClient()
        print("âœ… All clients initialized")
        
        # Step 1: Use existing voice input
        outputs_dir = Path("outputs")
        voice_files = list(outputs_dir.glob("voice_input_*.wav"))
        
        if not voice_files:
            print("âŒ No voice input files found for testing")
            return False
        
        test_file = sorted(voice_files)[-1]
        print(f"\nğŸµ Step 1: Using voice input: {test_file.name}")
        
        # Step 2: Transcribe
        print("ğŸ“ Step 2: Transcribing audio...")
        transcription = stt.transcribe_file(str(test_file))
        print(f"âœ… Transcription: '{transcription}'")
        
        if not transcription.strip():
            print("âš ï¸  Empty transcription, using fallback question")
            transcription = "What is artificial intelligence and how does it work?"
        
        # Step 3: Generate response
        print("ğŸ¤” Step 3: Generating AI response...")
        response = llm.generate(transcription, emotion="enthusiastic")
        print(f"âœ… AI Response: {response[:100]}{'...' if len(response) > 100 else ''}")
        
        # Step 4: Convert to speech
        print("ğŸ”Š Step 4: Converting response to speech...")
        output_audio = tts.synthesize(response, play_audio=False)
        print(f"âœ… Audio generated: {output_audio}")
        
        # Verify output file
        if output_audio.exists():
            size = output_audio.stat().st_size
            print(f"ğŸ“Š Output file size: {size} bytes")
            
            if size > 1000:  # Reasonable audio file size
                print("ğŸ‰ VOICE-TO-VOICE TEST SUCCESSFUL!")
                print("\nğŸ“‹ Pipeline Summary:")
                print(f"   ğŸ¤ Input: {test_file.name}")
                print(f"   ğŸ“ Transcription: '{transcription[:50]}...'")
                print(f"   ğŸ¤– AI Model: {'Gemini' if settings.use_gemini else 'OpenAI'}")
                print(f"   ğŸ”Š Output: {output_audio.name}")
                print(f"   â±ï¸  Pipeline: Voice â†’ Text â†’ AI â†’ Voice âœ…")
                return True
            else:
                print("âŒ Generated audio file is too small")
                return False
        else:
            print("âŒ Output audio file not created")
            return False
            
    except Exception as e:
        print(f"âŒ Voice-to-voice test failed: {e}")
        import traceback
        traceback.print_exc()
        return False

def test_text_to_voice_only():
    """Simpler test: just text input to voice output"""
    print("ğŸ“â¡ï¸ğŸ”Š Testing Text-to-Voice Only")
    print("=" * 40)
    
    try:
        from profai.llm import LLMClient
        from profai.tts import TTSClient
        
        # Initialize clients
        llm = LLMClient()
        tts = TTSClient()
        
        # Test question
        question = "Explain quantum computing in simple terms"
        print(f"ğŸ’­ Question: {question}")
        
        # Generate response
        print("ğŸ¤” Generating response...")
        response = llm.generate(question, emotion="friendly")
        print(f"âœ… Response: {response[:100]}{'...' if len(response) > 100 else ''}")
        
        # Convert to speech
        print("ğŸ”Š Converting to speech...")
        audio_path = tts.synthesize(response, play_audio=False)
        print(f"âœ… Audio generated: {audio_path}")
        
        return audio_path.exists() and audio_path.stat().st_size > 1000
        
    except Exception as e:
        print(f"âŒ Text-to-voice test failed: {e}")
        return False

def main():
    print("ğŸ¤ ProfAI Complete Voice Functionality Test")
    print("=" * 60)
    
    # Try the complete pipeline first
    print("ğŸš€ Attempting complete voice-to-voice pipeline...")
    if test_voice_to_voice_pipeline():
        print("\nğŸ‰ COMPLETE SUCCESS! All voice functionality is working.")
        return
    
    print("\nâš ï¸  Full pipeline failed, testing text-to-voice only...")
    if test_text_to_voice_only():
        print("\nâœ… Text-to-Voice works!")
        print("ğŸ’¡ For full voice-to-voice, ensure OpenAI API key is configured for STT")
    else:
        print("\nâŒ Text-to-Voice also failed")
        print("ğŸ”§ Please check your API key configuration")

if __name__ == "__main__":
    main()
